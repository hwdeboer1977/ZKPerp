{
  "version": 3,
  "sources": ["../../@demox-labs/aleo-wallet-adapter-react/useLocalStorage.ts", "../../@demox-labs/aleo-wallet-adapter-react/useWallet.ts", "../../@demox-labs/aleo-wallet-adapter-react/WalletProvider.tsx", "../../@demox-labs/aleo-wallet-adapter-react/index.ts"],
  "sourcesContent": ["import type { Dispatch, SetStateAction } from 'react';\nimport { useEffect, useRef, useState } from 'react';\n\nexport function useLocalStorage<T>(key: string, defaultState: T): [T, Dispatch<SetStateAction<T>>] {\n    const state = useState<T>(() => {\n        try {\n            const value = localStorage.getItem(key);\n            if (value) return JSON.parse(value) as T;\n        } catch (error: any) {\n            if (typeof window !== 'undefined') {\n                console.error(error);\n            }\n        }\n\n        return defaultState;\n    });\n    const value = state[0];\n\n    const isFirstRender = useRef(true);\n    useEffect(() => {\n        if (isFirstRender.current) {\n            isFirstRender.current = false;\n            return;\n        }\n        try {\n            if (value === null) {\n                localStorage.removeItem(key);\n            } else {\n                localStorage.setItem(key, JSON.stringify(value));\n            }\n        } catch (error: any) {\n            if (typeof window !== 'undefined') {\n                console.error(error);\n            }\n        }\n    }, [value, key]);\n\n    return state;\n}\n", "import { createContext, useContext } from 'react';\nimport {\n  Adapter,\n  AleoTransaction,\n  AleoDeployment,\n  DecryptPermission,\n  MessageSignerWalletAdapterProps,\n  WalletAdapterNetwork,\n  WalletName,\n  WalletReadyState\n} from '@demox-labs/aleo-wallet-adapter-base';\n\nexport interface Wallet {\n  adapter: Adapter;\n  readyState: WalletReadyState;\n}\n\nexport interface WalletContextState {\n  autoConnect: boolean;\n  wallets: Wallet[];\n  wallet: Wallet | null;\n  publicKey: string | null;\n  connecting: boolean;\n  connected: boolean;\n  disconnecting: boolean;\n\n  select(walletName: WalletName): void;\n  connect(decryptPermission: DecryptPermission, network: WalletAdapterNetwork, programs?: string[]): Promise<void>;\n  disconnect(): Promise<void>;\n\n  signMessage: MessageSignerWalletAdapterProps['signMessage'] | undefined;\n  decrypt: MessageSignerWalletAdapterProps['decrypt'] | undefined;\n  requestRecords: MessageSignerWalletAdapterProps['requestRecords'] | undefined;\n  requestTransaction: MessageSignerWalletAdapterProps['requestTransaction'] | undefined;\n  requestExecution: MessageSignerWalletAdapterProps['requestExecution'] | undefined;\n  requestBulkTransactions: MessageSignerWalletAdapterProps['requestBulkTransactions'] | undefined;\n  requestDeploy: MessageSignerWalletAdapterProps['requestDeploy'] | undefined;\n  transactionStatus: MessageSignerWalletAdapterProps['transactionStatus'] | undefined;\n  transitionViewKeys: MessageSignerWalletAdapterProps['transitionViewKeys'] | undefined;\n  getExecution: MessageSignerWalletAdapterProps['getExecution'] | undefined;\n  requestRecordPlaintexts: MessageSignerWalletAdapterProps['requestRecordPlaintexts'] | undefined;\n  requestTransactionHistory: MessageSignerWalletAdapterProps['requestTransactionHistory'] | undefined;\n}\n\nconst EMPTY_ARRAY: never[] = [];\n\nconst DEFAULT_CONTEXT = {\n  autoConnect: false,\n  connecting: false,\n  connected: false,\n  disconnecting: false,\n  select(_name: WalletName) {\n    console.error(constructMissingProviderErrorMessage('get', 'select'));\n  },\n  connect(_decryptPermission: DecryptPermission, _network: WalletAdapterNetwork, _programs?: string[]) {\n    return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'connect')));\n  },\n  disconnect() {\n    return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'disconnect')));\n  },\n  signMessage(_message: Uint8Array) {\n    return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'signMessage')));\n  },\n  decrypt(_cipherText: string, _tpk?: string, _programId?: string, _functionName?: string, _index?: number) {\n    return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'decrypt')));\n  },\n  requestRecords(_program: string) {\n    return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'requestRecords')));\n  },\n  requestTransaction(_transaction: AleoTransaction) {\n    return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'requestTransaction')));\n  },\n  requestExecution(_execution: AleoTransaction) {\n    return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'requestExecution')));\n  },\n  requestBulkTransactions(_transactions: AleoTransaction[]) {\n    return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'requestBulkTransactions')));\n  },\n  requestDeploy(_deployment: AleoDeployment) {\n    return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'requestDeploy')));\n  },\n  transactionStatus(_transactionId: string) {\n    return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'transactionStatus')));\n  },\n  transitionViewKeys(_transactionId: string) {\n    return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'transitionViewKeys')));\n  },\n  getExecution(_transactionId: string) {\n    return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'getExecution')));\n  },\n  requestRecordPlaintexts(_program: string) {\n    return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'requestRecordPlaintexts')));\n  },\n  requestTransactionHistory(_program: string) {\n    return Promise.reject(console.error(constructMissingProviderErrorMessage('get', 'requestTransactionHistory')));\n  }\n} as WalletContextState;\nObject.defineProperty(DEFAULT_CONTEXT, 'wallets', {\n  get() {\n    console.error(constructMissingProviderErrorMessage('read', 'wallets'));\n    return EMPTY_ARRAY;\n  },\n});\nObject.defineProperty(DEFAULT_CONTEXT, 'wallet', {\n  get() {\n    console.error(constructMissingProviderErrorMessage('read', 'wallet'));\n    return null;\n  },\n});\nObject.defineProperty(DEFAULT_CONTEXT, 'publicKey', {\n  get() {\n    console.error(constructMissingProviderErrorMessage('read', 'publicKey'));\n    return null;\n  },\n});\n\nfunction constructMissingProviderErrorMessage(action: string, valueName: string) {\n  return (\n    'You have tried to ' +\n    ` ${action} \"${valueName}\"` +\n    ' on a WalletContext without providing one.' +\n    ' Make sure to render a WalletProvider' +\n    ' as an ancestor of the component that uses ' +\n    'WalletContext'\n  );\n}\n\nexport const WalletContext = createContext<WalletContextState>(DEFAULT_CONTEXT as WalletContextState);\n\nexport function useWallet(): WalletContextState {\n  return useContext(WalletContext);\n}\n", "import {\n    Adapter,\n    MessageSignerWalletAdapterProps,\n    WalletNotSelectedError,\n    WalletError,\n    WalletName,\n    WalletNotConnectedError,\n    WalletNotReadyError,\n    WalletReadyState,\n    DecryptPermission,\n    WalletAdapterNetwork,\n    AleoTransaction,\n    AleoDeployment,\n} from '@demox-labs/aleo-wallet-adapter-base';\nimport type { FC, ReactNode } from 'react';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { useLocalStorage } from './useLocalStorage';\nimport type { Wallet } from './useWallet';\nimport { WalletContext } from './useWallet';\n\nexport interface WalletProviderProps {\n    children: ReactNode;\n    wallets: Adapter[];\n    decryptPermission?: DecryptPermission;\n    programs?: string[];\n    network?: WalletAdapterNetwork;\n    autoConnect?: boolean;\n    onError?: (error: WalletError) => void;\n    localStorageKey?: string;\n}\n\nconst initialState: {\n    wallet: Wallet | null;\n    adapter: Adapter | null;\n    publicKey: string | null;\n    connected: boolean;\n} = {\n    wallet: null,\n    adapter: null,\n    publicKey: null,\n    connected: false,\n};\n\nexport const WalletProvider: FC<WalletProviderProps> = ({\n    children,\n    wallets: adapters,\n    autoConnect = false,\n    decryptPermission = DecryptPermission.NoDecrypt,\n    network = WalletAdapterNetwork.TestnetBeta,\n    onError,\n    localStorageKey = 'walletName',\n    programs = []\n}) => {\n    const [name, setName] = useLocalStorage<WalletName | null>(localStorageKey, null);\n    const [{ wallet, adapter, publicKey, connected }, setState] = useState(initialState);\n    const readyState = adapter?.readyState || WalletReadyState.Unsupported;\n    const [connecting, setConnecting] = useState(false);\n    const [disconnecting, setDisconnecting] = useState(false);\n    const isConnecting = useRef(false);\n    const isDisconnecting = useRef(false);\n    const isUnloading = useRef(false);\n\n    // Wrap adapters to conform to the `Wallet` interface\n    const [wallets, setWallets] = useState(() =>\n        adapters.map((adapter) => ({\n            adapter,\n            readyState: adapter.readyState,\n        }))\n    );\n\n    // When the adapters change, start to listen for changes to their `readyState`\n    useEffect(() => {\n        // When the adapters change, wrap them to conform to the `Wallet` interface\n        setWallets((wallets) =>\n            adapters.map((adapter, index) => {\n                const wallet = wallets[index];\n                // If the wallet hasn't changed, return the same instance\n                return wallet && wallet.adapter === adapter && wallet.readyState === adapter.readyState\n                    ? wallet\n                    : {\n                          adapter: adapter,\n                          readyState: adapter.readyState,\n                      };\n            })\n        );\n\n        function handleReadyStateChange(this: Adapter, readyState: WalletReadyState) {\n            setWallets((prevWallets) => {\n                const index = prevWallets.findIndex(({ adapter }) => adapter === this);\n                if (index === -1) return prevWallets;\n\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const { adapter } = prevWallets[index]!;\n                return [...prevWallets.slice(0, index), { adapter, readyState }, ...prevWallets.slice(index + 1)];\n            });\n        }\n\n        adapters.forEach((adapter) => adapter.on('readyStateChange', handleReadyStateChange, adapter));\n        return () => adapters.forEach((adapter) => adapter.off('readyStateChange', handleReadyStateChange, adapter));\n    }, [adapters]);\n\n    // When the selected wallet changes, initialize the state\n    useEffect(() => {\n        const wallet = name && wallets.find(({ adapter }) => adapter.name === name);\n        if (wallet) {\n            setState({\n                wallet,\n                adapter: wallet.adapter,\n                connected: wallet.adapter.connected,\n                publicKey: wallet.adapter.publicKey\n            });\n        } else {\n            setState(initialState);\n        }\n    }, [name, wallets]);\n\n    // If the window is closing or reloading, ignore disconnect and error events from the adapter\n    useEffect(() => {\n        function listener() {\n            isUnloading.current = true;\n        }\n\n        window.addEventListener('beforeunload', listener);\n        return () => window.removeEventListener('beforeunload', listener);\n    }, [isUnloading]);\n\n    // Handle the adapter's connect event\n    const handleConnect = useCallback(() => {\n        if (!adapter) return;\n        setState((state) => ({ ...state, connected: adapter.connected, publicKey: adapter.publicKey }));\n    }, [adapter]);\n\n    // Handle the adapter's disconnect event\n    const handleDisconnect = useCallback(() => {\n        // Clear the selected wallet unless the window is unloading\n        if (!isUnloading.current) setName(null);\n    }, [isUnloading, setName]);\n\n    // Handle the adapter's error event, and local errors\n    const handleError = useCallback(\n        (error: WalletError) => {\n            // Call onError unless the window is unloading\n            if (!isUnloading.current) (onError || console.error)(error);\n            return error;\n        },\n        [isUnloading, onError]\n    );\n\n    // Setup and teardown event listeners when the adapter changes\n    useEffect(() => {\n        if (adapter) {\n            adapter.on('connect', handleConnect);\n            adapter.on('disconnect', handleDisconnect);\n            adapter.on('error', handleError);\n            return () => {\n                adapter.off('connect', handleConnect);\n                adapter.off('disconnect', handleDisconnect);\n                adapter.off('error', handleError);\n            };\n        }\n    }, [adapter, handleConnect, handleDisconnect, handleError]);\n\n    // When the adapter changes, disconnect the old one\n    useEffect(() => {\n        return () => {\n            adapter?.disconnect();\n        };\n    }, [adapter]);\n\n    // If autoConnect is enabled, try to connect when the adapter changes and is ready\n    useEffect(() => {\n        if (\n            isConnecting.current ||\n            connected ||\n            !autoConnect ||\n            !adapter ||\n            !(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable)\n        )\n            return;\n\n        (async function () {\n            isConnecting.current = true;\n            setConnecting(true);\n            try {\n                await adapter.connect(decryptPermission, network, programs);\n            } catch (error: any) {\n                // Clear the selected wallet\n                setName(null);\n                // Don't throw error, but handleError will still be called\n            } finally {\n                setConnecting(false);\n                isConnecting.current = false;\n            }\n        })();\n    }, [isConnecting, connected, autoConnect, adapter, readyState, setName]);\n\n    // Connect the adapter to the wallet\n    const connect = useCallback(async () => {\n        if (isConnecting.current || isDisconnecting.current || connected) return;\n        if (!adapter) throw handleError(new WalletNotSelectedError());\n\n        if (!(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable)) {\n            // Clear the selected wallet\n            setName(null);\n\n            if (typeof window !== 'undefined') {\n                window.open(adapter.url, '_blank');\n            }\n\n            throw handleError(new WalletNotReadyError());\n        }\n\n        isConnecting.current = true;\n        setConnecting(true);\n        try {\n            await adapter.connect(decryptPermission, network, programs);\n        } catch (error: any) {\n            // Clear the selected wallet\n            setName(null);\n            // Rethrow the error, and handleError will also be called\n            throw error;\n        } finally {\n            setConnecting(false);\n            isConnecting.current = false;\n        }\n    }, [isConnecting, isDisconnecting, connected, adapter, readyState, handleError, setName]);\n\n    // Disconnect the adapter from the wallet\n    const disconnect = useCallback(async () => {\n        if (isDisconnecting.current) return;\n        if (!adapter) return setName(null);\n\n        isDisconnecting.current = true;\n        setDisconnecting(true);\n        try {\n            await adapter.disconnect();\n        } catch (error: any) {\n            // Clear the selected wallet\n            setName(null);\n            // Rethrow the error, and handleError will also be called\n            throw error;\n        } finally {\n            setDisconnecting(false);\n            isDisconnecting.current = false;\n        }\n    }, [isDisconnecting, adapter, setName]);\n\n    // Sign an arbitrary message if the wallet supports it\n    const signMessage: MessageSignerWalletAdapterProps['signMessage'] | undefined = useMemo(\n        () =>\n            adapter && 'signMessage' in adapter\n                ? async (message) => {\n                      if (!connected) throw handleError(new WalletNotConnectedError());\n                      return await adapter.signMessage(message);\n                  }\n                : undefined,\n        [adapter, handleError, connected]\n    );\n\n    // Decrypt a ciphertext using the wallet\n    const decrypt: MessageSignerWalletAdapterProps['decrypt'] | undefined = useMemo(\n        () => \n            adapter && 'decrypt' in adapter\n                ? async (cipherText, tpk?: string, programId?: string, functionName?: string, index?: number) => {\n                    if (!connected) throw handleError(new WalletNotConnectedError());\n                        return await adapter.decrypt(cipherText, tpk, programId, functionName, index);\n                    }\n                : undefined,\n        [adapter, handleError, connected]\n    );\n\n    // Request records for a specific program\n    const requestRecords: MessageSignerWalletAdapterProps['requestRecords'] | undefined = useMemo(\n        () => \n            adapter && 'requestRecords' in adapter\n                ? async (program) => {\n                    if (!connected) throw handleError(new WalletNotConnectedError());\n                        return await adapter.requestRecords(program);\n                    }\n                : undefined,\n        [adapter, handleError, connected]\n    );\n\n    // Request transaction\n    const requestTransaction: MessageSignerWalletAdapterProps['requestTransaction'] | undefined = useMemo(\n        () => \n            adapter && 'requestTransaction' in adapter\n                ? async (transaction: AleoTransaction) => {\n                    if (!connected) throw handleError(new WalletNotConnectedError());\n                    return await adapter.requestTransaction(transaction);\n                }\n                : undefined,\n        [adapter, handleError, connected]\n    );\n\n    // Request execution\n    const requestExecution: MessageSignerWalletAdapterProps['requestExecution'] | undefined = useMemo(\n        () => \n            adapter && 'requestExecution' in adapter\n                ? async (transaction: AleoTransaction) => {\n                    if (!connected) throw handleError(new WalletNotConnectedError());\n                    return await adapter.requestExecution(transaction);\n                }\n                : undefined,\n        [adapter, handleError, connected]\n    );\n\n    // Request bulk transactions\n    const requestBulkTransactions: MessageSignerWalletAdapterProps['requestBulkTransactions'] | undefined = useMemo(\n        () =>\n            adapter && 'requestBulkTransactions' in adapter\n                ? async (transactions: AleoTransaction[]) => {\n                    if (!connected) throw handleError(new WalletNotConnectedError());\n                    return await adapter.requestBulkTransactions(transactions);\n                }\n                : undefined,\n        [adapter, handleError, connected]\n    );\n\n    // Request deploy\n    const requestDeploy: MessageSignerWalletAdapterProps['requestDeploy'] | undefined = useMemo(\n        () =>\n            adapter && 'requestDeploy' in adapter\n                ? async (deployment: AleoDeployment) => {\n                    if (!connected) throw handleError(new WalletNotConnectedError());\n                    return await adapter.requestDeploy(deployment);\n                }\n                : undefined,\n        [adapter, handleError, connected]\n    );\n\n    // Request transaction status\n    const transactionStatus: MessageSignerWalletAdapterProps['transactionStatus'] | undefined = useMemo(\n        () =>\n            adapter && 'transactionStatus' in adapter\n                ? async (transactionId) => {\n                    if (!connected) throw handleError(new WalletNotConnectedError());\n                    return await adapter.transactionStatus(transactionId);\n                }\n                : undefined,\n        [adapter, handleError, connected]\n    );\n\n    // Request transition view keys\n    const transitionViewKeys: MessageSignerWalletAdapterProps['transitionViewKeys'] | undefined = useMemo(\n        () =>\n            adapter && 'transitionViewKeys' in adapter\n                ? async (transactionId) => {\n                    if (!connected) throw handleError(new WalletNotConnectedError());\n                    return await adapter.transitionViewKeys(transactionId);\n                }\n                : undefined,\n        [adapter, handleError, connected]\n    );\n\n    // Request Execution\n    const getExecution: MessageSignerWalletAdapterProps['getExecution'] | undefined = useMemo(\n        () =>\n            adapter && 'getExecution' in adapter\n                ? async (transactionId) => {\n                    if (!connected) throw handleError(new WalletNotConnectedError());\n                    return await adapter.getExecution(transactionId);\n                }\n                : undefined,\n        [adapter, handleError, connected]\n    );\n\n    // Request the on-chain records plaintexts for a specific program\n    const requestRecordPlaintexts: MessageSignerWalletAdapterProps['requestRecordPlaintexts'] | undefined = useMemo(\n        () => \n            adapter && 'requestRecordPlaintexts' in adapter\n                ? async (program) => {\n                    if (!connected) throw handleError(new WalletNotConnectedError());\n                        return await adapter.requestRecordPlaintexts(program);\n                    }\n                : undefined,\n        [adapter, handleError, connected]\n    );\n\n    // Request on-chain transaction history for a specific program\n    const requestTransactionHistory: MessageSignerWalletAdapterProps['requestTransactionHistory'] | undefined = useMemo(\n        () => \n            adapter && 'requestTransactionHistory' in adapter\n                ? async (program) => {\n                    if (!connected) throw handleError(new WalletNotConnectedError());\n                        return await adapter.requestTransactionHistory(program);\n                    }\n                : undefined,\n        [adapter, handleError, connected]\n    );\n\n    return (\n        <WalletContext.Provider\n            value={{\n                autoConnect,\n                decryptPermission,\n                wallets,\n                wallet,\n                publicKey,\n                connected,\n                connecting,\n                disconnecting,\n                select: setName,\n                connect,\n                disconnect,\n                signMessage,\n                decrypt,\n                requestRecords,\n                requestTransaction,\n                requestExecution,\n                requestBulkTransactions,\n                requestDeploy,\n                transactionStatus,\n                transitionViewKeys,\n                getExecution,\n                requestRecordPlaintexts,\n                requestTransactionHistory\n            }}\n        >\n            {children}\n        </WalletContext.Provider>\n    );\n};\n", "export * from './WalletProvider';\nexport * from './useLocalStorage';\nexport * from './useWallet';"],
  "mappings": "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",
  "names": ["value", "adapter", "wallets", "wallet", "readyState"]
}
