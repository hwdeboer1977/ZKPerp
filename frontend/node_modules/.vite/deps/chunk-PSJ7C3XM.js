import {
  require_react
} from "./chunk-3RM6SWVL.js";
import {
  require_dist
} from "./chunk-PU2N7MMA.js";
import {
  __commonJS
} from "./chunk-5WRI5ZAA.js";

// node_modules/@demox-labs/aleo-wallet-adapter-react/dist/useLocalStorage.js
var require_useLocalStorage = __commonJS({
  "node_modules/@demox-labs/aleo-wallet-adapter-react/dist/useLocalStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useLocalStorage = void 0;
    var react_1 = require_react();
    function useLocalStorage(key, defaultState) {
      const state = (0, react_1.useState)(() => {
        try {
          const value2 = localStorage.getItem(key);
          if (value2)
            return JSON.parse(value2);
        } catch (error) {
          if (typeof window !== "undefined") {
            console.error(error);
          }
        }
        return defaultState;
      });
      const value = state[0];
      const isFirstRender = (0, react_1.useRef)(true);
      (0, react_1.useEffect)(() => {
        if (isFirstRender.current) {
          isFirstRender.current = false;
          return;
        }
        try {
          if (value === null) {
            localStorage.removeItem(key);
          } else {
            localStorage.setItem(key, JSON.stringify(value));
          }
        } catch (error) {
          if (typeof window !== "undefined") {
            console.error(error);
          }
        }
      }, [value, key]);
      return state;
    }
    exports.useLocalStorage = useLocalStorage;
  }
});

// node_modules/@demox-labs/aleo-wallet-adapter-react/dist/useWallet.js
var require_useWallet = __commonJS({
  "node_modules/@demox-labs/aleo-wallet-adapter-react/dist/useWallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useWallet = exports.WalletContext = void 0;
    var react_1 = require_react();
    var EMPTY_ARRAY = [];
    var DEFAULT_CONTEXT = {
      autoConnect: false,
      connecting: false,
      connected: false,
      disconnecting: false,
      select(_name) {
        console.error(constructMissingProviderErrorMessage("get", "select"));
      },
      connect(_decryptPermission, _network, _programs) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "connect")));
      },
      disconnect() {
        return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "disconnect")));
      },
      signMessage(_message) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "signMessage")));
      },
      decrypt(_cipherText, _tpk, _programId, _functionName, _index) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "decrypt")));
      },
      requestRecords(_program) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "requestRecords")));
      },
      requestTransaction(_transaction) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "requestTransaction")));
      },
      requestExecution(_execution) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "requestExecution")));
      },
      requestBulkTransactions(_transactions) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "requestBulkTransactions")));
      },
      requestDeploy(_deployment) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "requestDeploy")));
      },
      transactionStatus(_transactionId) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "transactionStatus")));
      },
      transitionViewKeys(_transactionId) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "transitionViewKeys")));
      },
      getExecution(_transactionId) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "getExecution")));
      },
      requestRecordPlaintexts(_program) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "requestRecordPlaintexts")));
      },
      requestTransactionHistory(_program) {
        return Promise.reject(console.error(constructMissingProviderErrorMessage("get", "requestTransactionHistory")));
      }
    };
    Object.defineProperty(DEFAULT_CONTEXT, "wallets", {
      get() {
        console.error(constructMissingProviderErrorMessage("read", "wallets"));
        return EMPTY_ARRAY;
      }
    });
    Object.defineProperty(DEFAULT_CONTEXT, "wallet", {
      get() {
        console.error(constructMissingProviderErrorMessage("read", "wallet"));
        return null;
      }
    });
    Object.defineProperty(DEFAULT_CONTEXT, "publicKey", {
      get() {
        console.error(constructMissingProviderErrorMessage("read", "publicKey"));
        return null;
      }
    });
    function constructMissingProviderErrorMessage(action, valueName) {
      return `You have tried to  ${action} "${valueName}" on a WalletContext without providing one. Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext`;
    }
    exports.WalletContext = (0, react_1.createContext)(DEFAULT_CONTEXT);
    function useWallet() {
      return (0, react_1.useContext)(exports.WalletContext);
    }
    exports.useWallet = useWallet;
  }
});

// node_modules/@demox-labs/aleo-wallet-adapter-react/dist/WalletProvider.js
var require_WalletProvider = __commonJS({
  "node_modules/@demox-labs/aleo-wallet-adapter-react/dist/WalletProvider.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletProvider = void 0;
    var aleo_wallet_adapter_base_1 = require_dist();
    var react_1 = __importStar(require_react());
    var useLocalStorage_1 = require_useLocalStorage();
    var useWallet_1 = require_useWallet();
    var initialState = {
      wallet: null,
      adapter: null,
      publicKey: null,
      connected: false
    };
    var WalletProvider = ({ children, wallets: adapters, autoConnect = false, decryptPermission = aleo_wallet_adapter_base_1.DecryptPermission.NoDecrypt, network = aleo_wallet_adapter_base_1.WalletAdapterNetwork.TestnetBeta, onError, localStorageKey = "walletName", programs = [] }) => {
      const [name, setName] = (0, useLocalStorage_1.useLocalStorage)(localStorageKey, null);
      const [{ wallet, adapter, publicKey, connected }, setState] = (0, react_1.useState)(initialState);
      const readyState = adapter?.readyState || aleo_wallet_adapter_base_1.WalletReadyState.Unsupported;
      const [connecting, setConnecting] = (0, react_1.useState)(false);
      const [disconnecting, setDisconnecting] = (0, react_1.useState)(false);
      const isConnecting = (0, react_1.useRef)(false);
      const isDisconnecting = (0, react_1.useRef)(false);
      const isUnloading = (0, react_1.useRef)(false);
      const [wallets, setWallets] = (0, react_1.useState)(() => adapters.map((adapter2) => ({
        adapter: adapter2,
        readyState: adapter2.readyState
      })));
      (0, react_1.useEffect)(() => {
        setWallets((wallets2) => adapters.map((adapter2, index) => {
          const wallet2 = wallets2[index];
          return wallet2 && wallet2.adapter === adapter2 && wallet2.readyState === adapter2.readyState ? wallet2 : {
            adapter: adapter2,
            readyState: adapter2.readyState
          };
        }));
        function handleReadyStateChange(readyState2) {
          setWallets((prevWallets) => {
            const index = prevWallets.findIndex(({ adapter: adapter3 }) => adapter3 === this);
            if (index === -1)
              return prevWallets;
            const { adapter: adapter2 } = prevWallets[index];
            return [...prevWallets.slice(0, index), { adapter: adapter2, readyState: readyState2 }, ...prevWallets.slice(index + 1)];
          });
        }
        adapters.forEach((adapter2) => adapter2.on("readyStateChange", handleReadyStateChange, adapter2));
        return () => adapters.forEach((adapter2) => adapter2.off("readyStateChange", handleReadyStateChange, adapter2));
      }, [adapters]);
      (0, react_1.useEffect)(() => {
        const wallet2 = name && wallets.find(({ adapter: adapter2 }) => adapter2.name === name);
        if (wallet2) {
          setState({
            wallet: wallet2,
            adapter: wallet2.adapter,
            connected: wallet2.adapter.connected,
            publicKey: wallet2.adapter.publicKey
          });
        } else {
          setState(initialState);
        }
      }, [name, wallets]);
      (0, react_1.useEffect)(() => {
        function listener() {
          isUnloading.current = true;
        }
        window.addEventListener("beforeunload", listener);
        return () => window.removeEventListener("beforeunload", listener);
      }, [isUnloading]);
      const handleConnect = (0, react_1.useCallback)(() => {
        if (!adapter)
          return;
        setState((state) => ({ ...state, connected: adapter.connected, publicKey: adapter.publicKey }));
      }, [adapter]);
      const handleDisconnect = (0, react_1.useCallback)(() => {
        if (!isUnloading.current)
          setName(null);
      }, [isUnloading, setName]);
      const handleError = (0, react_1.useCallback)((error) => {
        if (!isUnloading.current)
          (onError || console.error)(error);
        return error;
      }, [isUnloading, onError]);
      (0, react_1.useEffect)(() => {
        if (adapter) {
          adapter.on("connect", handleConnect);
          adapter.on("disconnect", handleDisconnect);
          adapter.on("error", handleError);
          return () => {
            adapter.off("connect", handleConnect);
            adapter.off("disconnect", handleDisconnect);
            adapter.off("error", handleError);
          };
        }
      }, [adapter, handleConnect, handleDisconnect, handleError]);
      (0, react_1.useEffect)(() => {
        return () => {
          adapter?.disconnect();
        };
      }, [adapter]);
      (0, react_1.useEffect)(() => {
        if (isConnecting.current || connected || !autoConnect || !adapter || !(readyState === aleo_wallet_adapter_base_1.WalletReadyState.Installed || readyState === aleo_wallet_adapter_base_1.WalletReadyState.Loadable))
          return;
        (async function() {
          isConnecting.current = true;
          setConnecting(true);
          try {
            await adapter.connect(decryptPermission, network, programs);
          } catch (error) {
            setName(null);
          } finally {
            setConnecting(false);
            isConnecting.current = false;
          }
        })();
      }, [isConnecting, connected, autoConnect, adapter, readyState, setName]);
      const connect = (0, react_1.useCallback)(async () => {
        if (isConnecting.current || isDisconnecting.current || connected)
          return;
        if (!adapter)
          throw handleError(new aleo_wallet_adapter_base_1.WalletNotSelectedError());
        if (!(readyState === aleo_wallet_adapter_base_1.WalletReadyState.Installed || readyState === aleo_wallet_adapter_base_1.WalletReadyState.Loadable)) {
          setName(null);
          if (typeof window !== "undefined") {
            window.open(adapter.url, "_blank");
          }
          throw handleError(new aleo_wallet_adapter_base_1.WalletNotReadyError());
        }
        isConnecting.current = true;
        setConnecting(true);
        try {
          await adapter.connect(decryptPermission, network, programs);
        } catch (error) {
          setName(null);
          throw error;
        } finally {
          setConnecting(false);
          isConnecting.current = false;
        }
      }, [isConnecting, isDisconnecting, connected, adapter, readyState, handleError, setName]);
      const disconnect = (0, react_1.useCallback)(async () => {
        if (isDisconnecting.current)
          return;
        if (!adapter)
          return setName(null);
        isDisconnecting.current = true;
        setDisconnecting(true);
        try {
          await adapter.disconnect();
        } catch (error) {
          setName(null);
          throw error;
        } finally {
          setDisconnecting(false);
          isDisconnecting.current = false;
        }
      }, [isDisconnecting, adapter, setName]);
      const signMessage = (0, react_1.useMemo)(() => adapter && "signMessage" in adapter ? async (message) => {
        if (!connected)
          throw handleError(new aleo_wallet_adapter_base_1.WalletNotConnectedError());
        return await adapter.signMessage(message);
      } : void 0, [adapter, handleError, connected]);
      const decrypt = (0, react_1.useMemo)(() => adapter && "decrypt" in adapter ? async (cipherText, tpk, programId, functionName, index) => {
        if (!connected)
          throw handleError(new aleo_wallet_adapter_base_1.WalletNotConnectedError());
        return await adapter.decrypt(cipherText, tpk, programId, functionName, index);
      } : void 0, [adapter, handleError, connected]);
      const requestRecords = (0, react_1.useMemo)(() => adapter && "requestRecords" in adapter ? async (program) => {
        if (!connected)
          throw handleError(new aleo_wallet_adapter_base_1.WalletNotConnectedError());
        return await adapter.requestRecords(program);
      } : void 0, [adapter, handleError, connected]);
      const requestTransaction = (0, react_1.useMemo)(() => adapter && "requestTransaction" in adapter ? async (transaction) => {
        if (!connected)
          throw handleError(new aleo_wallet_adapter_base_1.WalletNotConnectedError());
        return await adapter.requestTransaction(transaction);
      } : void 0, [adapter, handleError, connected]);
      const requestExecution = (0, react_1.useMemo)(() => adapter && "requestExecution" in adapter ? async (transaction) => {
        if (!connected)
          throw handleError(new aleo_wallet_adapter_base_1.WalletNotConnectedError());
        return await adapter.requestExecution(transaction);
      } : void 0, [adapter, handleError, connected]);
      const requestBulkTransactions = (0, react_1.useMemo)(() => adapter && "requestBulkTransactions" in adapter ? async (transactions) => {
        if (!connected)
          throw handleError(new aleo_wallet_adapter_base_1.WalletNotConnectedError());
        return await adapter.requestBulkTransactions(transactions);
      } : void 0, [adapter, handleError, connected]);
      const requestDeploy = (0, react_1.useMemo)(() => adapter && "requestDeploy" in adapter ? async (deployment) => {
        if (!connected)
          throw handleError(new aleo_wallet_adapter_base_1.WalletNotConnectedError());
        return await adapter.requestDeploy(deployment);
      } : void 0, [adapter, handleError, connected]);
      const transactionStatus = (0, react_1.useMemo)(() => adapter && "transactionStatus" in adapter ? async (transactionId) => {
        if (!connected)
          throw handleError(new aleo_wallet_adapter_base_1.WalletNotConnectedError());
        return await adapter.transactionStatus(transactionId);
      } : void 0, [adapter, handleError, connected]);
      const transitionViewKeys = (0, react_1.useMemo)(() => adapter && "transitionViewKeys" in adapter ? async (transactionId) => {
        if (!connected)
          throw handleError(new aleo_wallet_adapter_base_1.WalletNotConnectedError());
        return await adapter.transitionViewKeys(transactionId);
      } : void 0, [adapter, handleError, connected]);
      const getExecution = (0, react_1.useMemo)(() => adapter && "getExecution" in adapter ? async (transactionId) => {
        if (!connected)
          throw handleError(new aleo_wallet_adapter_base_1.WalletNotConnectedError());
        return await adapter.getExecution(transactionId);
      } : void 0, [adapter, handleError, connected]);
      const requestRecordPlaintexts = (0, react_1.useMemo)(() => adapter && "requestRecordPlaintexts" in adapter ? async (program) => {
        if (!connected)
          throw handleError(new aleo_wallet_adapter_base_1.WalletNotConnectedError());
        return await adapter.requestRecordPlaintexts(program);
      } : void 0, [adapter, handleError, connected]);
      const requestTransactionHistory = (0, react_1.useMemo)(() => adapter && "requestTransactionHistory" in adapter ? async (program) => {
        if (!connected)
          throw handleError(new aleo_wallet_adapter_base_1.WalletNotConnectedError());
        return await adapter.requestTransactionHistory(program);
      } : void 0, [adapter, handleError, connected]);
      return react_1.default.createElement(useWallet_1.WalletContext.Provider, { value: {
        autoConnect,
        decryptPermission,
        wallets,
        wallet,
        publicKey,
        connected,
        connecting,
        disconnecting,
        select: setName,
        connect,
        disconnect,
        signMessage,
        decrypt,
        requestRecords,
        requestTransaction,
        requestExecution,
        requestBulkTransactions,
        requestDeploy,
        transactionStatus,
        transitionViewKeys,
        getExecution,
        requestRecordPlaintexts,
        requestTransactionHistory
      } }, children);
    };
    exports.WalletProvider = WalletProvider;
  }
});

// node_modules/@demox-labs/aleo-wallet-adapter-react/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@demox-labs/aleo-wallet-adapter-react/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_WalletProvider(), exports);
    __exportStar(require_useLocalStorage(), exports);
    __exportStar(require_useWallet(), exports);
  }
});

export {
  require_dist2 as require_dist
};
//# sourceMappingURL=chunk-PSJ7C3XM.js.map
